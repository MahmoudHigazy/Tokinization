template<class PIXELTYPE>
DsBaseMemoryImage* DsMemoryImage<PIXELTYPE>::AverageSmoothing(int /*MaskSize*/) throw(...)
{
	DsBaseMemoryImage* pFilteredImage = (DsBaseMemoryImage*)this->Clone();
	DsBaseMemoryImage* pTempImage     = (DsBaseMemoryImage*)this->Clone();
	int Width						  = pFilteredImage->GetWidth();
	int Height						  = pFilteredImage->GetHeight();
	PIXELTYPE* pData       =   (PIXELTYPE*)pFilteredImage->GetBuffer();
	PIXELTYPE* pTempData   =   (PIXELTYPE*)pTempImage->GetBuffer();
	if (!pData)
	{
		return NULL;
	}
	for (int w=2;w<Width-2;w++)
	{
		for (int h=2;h<Height-2;h++)	
		{
			pData[w + h*(Width)] = (PIXELTYPE)
			(
				(
						0.5 *(   (double)pTempData[(w-1) + (h-1)*(Width)]
					+(double)pTempData[(w-1) + (h  )*(Width)]
					+(double)pTempData[(w-1) + (h+1)*(Width)]
					+(double)pTempData[(w  ) + (h-1)*(Width)]
					+(double)pTempData[(w  ) + (h+1)*(Width)]
					+(double)pTempData[(w+1) + (h-1)*(Width)]
					+(double)pTempData[(w+1) + (h  )*(Width)]
					+(double)pTempData[(w+1) + (h+1)*(Width)]
					)
						+1.0 * pTempData[(w  ) + (h  )*(Width)]
				)/5
			);
		}
	}
	delete pTempImage;
	return pFilteredImage;
}

template<>
bool DsMemoryImage<DsWORD>::CombineImages(DsBaseMemoryImage* /*pRImage*/,DsBaseMemoryImage* /*pGImage*/, enCombinationOperation /*Op*/) throw(...)
{
	return false;
}

template<>
bool DsMemoryImage<float>::CombineImages(DsBaseMemoryImage* pImage1,DsBaseMemoryImage* pImage2, enCombinationOperation Op) throw(...)
{
	if (!pImage1 || !pImage2)
	{
		DSERROR(_CLASS_FUNCTION_NAME_,GetObjectName(),(ERROR_GLOBAL_USER_INVALID_POINTER),P3,false);
		return false;
	}
	int ImgSize = pImage1->GetImageSize();
	int BitsPerPixel = pImage1->GetBitsPerPixel();
	if (!ImgSize)
	{
		DSERROR(_CLASS_FUNCTION_NAME_,GetObjectName(),ERROR_DS_MEMORY_IMAGE_SIZE_ERROR,P3,false);
		return false;
	}
	int Width1  = pImage1->GetWidth();
	int Height1 = pImage1->GetHeight();
	int Width2  = pImage2->GetWidth();
	int Height2 = pImage2->GetHeight();
	DsBaseMemoryImage*pTempImage1 = pImage1;
	DsBaseMemoryImage*pTempImage2 = pImage2;
	bool bDeleteTempImages = false;
	if(	(Width1!=Width2)||(Height1!=Height2)||(BitsPerPixel != pImage2->GetBitsPerPixel()))
	{
		Width1  = max(Width1,Width2);
		Height1 = max(Height1,Height2);
		pTempImage1 = pImage1->GetImageWithBigSize(Width1,Height1);
		pTempImage2 = pImage2->GetImageWithBigSize(Width1,Height1);
		bDeleteTempImages = true;
	}
	
	ImgSize   = Width1*Height1;
	if(!ImgSize|| !Width1 || !(Height1)||(BitsPerPixel != pTempImage2->GetBitsPerPixel()))
	{
		DSERROR(_CLASS_FUNCTION_NAME_,GetObjectName(),ERROR_DS_MEMORY_IMAGE_SIZE_ERROR,P3,false);
		return false;
	}
	AllocateBuffer(Width1,Height1,sizeof(float)*8/*GetBitsPerPixel()*/);
	float* pData  = m_pData;
	if (BitsPerPixel==8)
	{
		DsBYTE* Buffer1 = (DsBYTE*) pTempImage1->GetBuffer();
		DsBYTE* Buffer2 = (DsBYTE*) pTempImage2->GetBuffer();
		if (Op == ADDITION)
		{
			for(int i = 0 ; i < ImgSize ; i++,Buffer1++,Buffer2++,pData++)
			{
				*pData = static_cast<float>(*Buffer1)+static_cast<float>(*Buffer2);
			}
		} 
		else 
		{
			for(int i = 0 ; i < ImgSize ; i++,Buffer1++,Buffer2++,pData++)
			{
				*pData = static_cast<float>(*Buffer1)*static_cast<float>(*Buffer2);
			}
		}
	} 
	else if (BitsPerPixel==16)
	{
		DsWORD* Buffer1 = (DsWORD*) pTempImage1->GetBuffer();
		DsWORD* Buffer2 = (DsWORD*) pTempImage2->GetBuffer();
	if (Op == ADDITION)
	{
		for(int i = 0 ; i < ImgSize ; i++,Buffer1++,Buffer2++,pData++)
		{
			*pData = static_cast<float>(*Buffer1)+static_cast<float>(*Buffer2);
		}
	} 
	else
	{
		for(int i = 0 ; i < ImgSize ; i++,Buffer1++,Buffer2++,pData++)
		{
			*pData = static_cast<float>(*Buffer1)*static_cast<float>(*Buffer2);
		}
	}
	}
	else if (BitsPerPixel==32)
	{
		float* Buffer1 = (float*) pTempImage1->GetBuffer();
		float* Buffer2= (float*) pTempImage2->GetBuffer();

		if (Op == ADDITION)
		{
			for(int i = 0 ; i < ImgSize ; i++,Buffer1++,Buffer2++,pData++)
			{
				*pData = (*Buffer1)+(*Buffer2);
			}
		} 
		else
		{
			for(int i = 0 ; i < ImgSize ; i++,Buffer1++,Buffer2++,pData++)
			{
				*pData = (*Buffer1)*(*Buffer2);
			}
		}
	}
	else
	{
		DSERROR(_CLASS_FUNCTION_NAME_,GetObjectName(),(ERROR_DS_MEMORY_IMAGE_SIZE_ERROR),P3,false);
		return false;
	}
	if (bDeleteTempImages)
	{
		delete pTempImage1;
		delete pTempImage2;
	}
	return true;
}

DsBaseMemoryImage* MyoDisplayStrainImage::CombineSliceImage(bool bRemoveNoise, DsLinkedList* pAnatomyImages, DsLinkedList* pStrainImages, int ImageIndex, float IL0, DsPalette* pGreyPalette, enDisplayMode displayMode, DsPalette* pStrainPalette)
{
	DsBaseMemoryImage* pAnatomyImg = NULL;
	DsBaseMemoryImage* pStrainImg = NULL;

	pAnatomyImg = (DsBaseMemoryImage*)pAnatomyImages->GetAt(ImageIndex);
	pStrainImg = (DsBaseMemoryImage*)pStrainImages->GetAt(ImageIndex);

	if (pAnatomyImg && pStrainImg)
	{
		MyoImagesList* pAnatomyImagesList = new MyoImagesList();
		if (ImageIndex == 0)
		{
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(0));
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(1));
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(2));
		}
		else if (ImageIndex == pAnatomyImages->GetSize() - 1)
		{
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(pAnatomyImages->GetSize() - 3));
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(pAnatomyImages->GetSize() - 2));
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(pAnatomyImages->GetSize() - 1));
		}
		else
		{
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(ImageIndex - 1));
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(ImageIndex));
			pAnatomyImagesList->AddImage((DsBaseMemoryImage*)pAnatomyImages->GetAt(ImageIndex + 1));
		}
		DsBaseMemoryImage* pI_n = NULL;
		float usedIL0 = IL0;
		if (bRemoveNoise)
		{
			pI_n = pAnatomyImagesList->CreateCutOffImageFromMean(IL0, 100, 0.95F);
		}
		else
		{
			usedIL0 = 0.0f;
			pI_n = pAnatomyImagesList->CreateCutOffImageFromMean(0, 100, 1.1F);
		}

		//*pI_n *= 255;


		int imgSize = pAnatomyImg->GetImageSize();
		float* pAnatomyTemp = (float*)pAnatomyImg->GetBuffer();
		float* pSTrainTemp = (float*)pStrainImg->GetBuffer();
		DsBaseMemoryImage* pNewStrain = new DsMemoryImage<float>();
		float* pNewSTrainTemp = (float*)pNewStrain->AllocateBuffer(pAnatomyImg->GetWidth(), pAnatomyImg->GetHeight(), 32);
		for (int count = 0; count < imgSize; count++)
		{
			int factor = ((pAnatomyTemp[count] > usedIL0 ? 1 : 0) || abs(pSTrainTemp[count] + 1.5) > 6.7 ? 1 : 0);
			pNewSTrainTemp[count] = factor == 0 ? UNDEFINED_VALUE : pSTrainTemp[count] * factor;
		}

		DsMemoryImage<DsDWORD>* pCombinedImage = NULL;
		CombineAnatomyWithStrain(pI_n, pCombinedImage, pNewStrain, pGreyPalette, displayMode, pStrainPalette);

		delete pNewStrain;
		delete pI_n;
		pAnatomyImagesList->Clear();
		delete pAnatomyImagesList;

		return pCombinedImage;
	}
	return NULL;
}

DsBaseMemoryImage* MyoImagesList::CreateCutOffImageFromMean(float IL0, int nEdges, float NoiseThreshold )
{
	DsBaseMemoryImage* pIn = GetMeanImage();
	float max_signal_n = pIn->CalculateMaximumSignal(nEdges, NoiseThreshold);
	DsBaseMemoryImage* pI_n = pIn->CreateImageFromCutOff(max_signal_n,IL0);

	delete pIn;

	return pI_n;
}

template <class PIXELTYPE>
 DsBaseMemoryImage* DsMemoryImage<PIXELTYPE>::CreateImageFromCutOff(float MaximumSignal, float IL)
 {
	 DsBaseMemoryImage* pI = new DsMemoryImage<float>();
	 float*pIData = (float*)pI->AllocateBuffer(m_nWidth, m_nHeight, 32);
	 int ImageSize = m_nHeight*m_nWidth;
	 float diff = MaximumSignal - IL;
	 for(int count=0;count<ImageSize;count++)
	 {
		 int iN;
		 if(m_pData[count] > IL)
		 {
			 iN = 1;
			 pIData[count] = (((m_pData[count] - IL) * iN) / diff);
		 }
		 else
		 {
			 pIData[count] = 0;
		 }
	 }

	 return pI;
 }
DsBaseMemoryImage* MyoImagesList::GetMeanImage()
{
	int nFrames = m_pImagesList->GetSize();
	DsBaseMemoryImage* pImage = (DsBaseMemoryImage*)m_pImagesList->GetAt(0);
	int Width = pImage->GetWidth();
	int Height = pImage->GetHeight();

	//Create the representative image	
	DsMemoryImage<float>*pMeanImage				= new DsMemoryImage<float>();
	float* pBuffer = (float*)pMeanImage->AllocateBuffer(Width,Height,32);
	memset(pBuffer,0,sizeof(float)*Width*Height);


	float StrainValue = 0;	

	for (int RowCount = 0; RowCount < Height ; RowCount++)
	{		
		for (int ColCount = 0; ColCount < Width ; ColCount++)
		{	
			//float*pArray = new float[nFrames];
			float meanValue = 0.0f;
			int nCounts = 0;
			for (int FrameCount = 0 ; FrameCount < nFrames; FrameCount++)
			{
				pImage = (DsBaseMemoryImage*)m_pImagesList->GetAt(FrameCount);				
				float*pImageBuffer = (float*)pImage->GetBuffer();
				StrainValue = pImageBuffer[RowCount*Width+ColCount];
				//pImage->GetPixelValue((float)ColCount,(float)RowCount,StrainValue,false);


				if (!FLOAT_EQ(StrainValue, UNDEFINED_VALUE))
				{
					meanValue += StrainValue;
					nCounts++;
				}

				//pArray[FrameCount] = StrainValue;
			}
			meanValue = nCounts == 0 ? UNDEFINED_VALUE : meanValue / nCounts; //DsMathLibrary::GetMeanOfValues(pArray,nFrames);
			//delete []pArray;
			pMeanImage->SetPixelValue(ColCount,RowCount,meanValue);	
		}
	}	
	return pMeanImage;
}

float MyoImagesList::CalculateMaximumSignal(int nEdges, float NoiseThreshold)
{
	MyoHistData* pHistData = HistCounts(nEdges);

	float max_signal = DsMathLibrary::CalculateMaximumSignal(pHistData, nEdges, NoiseThreshold);

	delete pHistData;
	return max_signal;
}

MyoHistData* MyoImagesList::HistCounts( int nEdges)
{
	
	unsigned int nMin = 0;
	unsigned int nMax = 0;
	GetMinMaxValues(nMin,nMax);

	MyoHistData* pHistData = DsMathLibrary::GetHistData(nMin, nMax, nEdges);
	
	GetPixelValueCount(pHistData,nEdges);

	return pHistData;
}
MyoHistData* DsMathLibrary::GetHistData(int nMin, int nMax, int nEdges)
{
	MyoHistData* pHistData = NULL;

	float step = ((float)nMax - (float)nMin)/(float)nEdges;
	pHistData = new MyoHistData(nEdges);

	pHistData->AddEdge(0, (float)nMin);

	for (int iEdge = 0; iEdge < nEdges; iEdge++)
	{
		pHistData->AddEdge(iEdge+1, pHistData->GetEdgeValue(iEdge) + step);
	}

	return pHistData;
}
void MyoImagesList::GetPixelValueCount( MyoHistData* pHistData, int nEdges )
{
	int size = m_pImagesList->GetSize();
	for(int imageIndex = 0; imageIndex < size; imageIndex++)
	{
		DsBaseMemoryImage* image = (DsBaseMemoryImage*)m_pImagesList->GetAt(imageIndex);
		image->GetPixelValueCount(pHistData, nEdges);		
	}
}

float DsMathLibrary::CalculateMaximumSignal(MyoHistData* pHistData, int nEdges, float NoiseThreshold)
{
	float* pN_H = DsMathLibrary::Div(pHistData->GetNH(), nEdges, DsMathLibrary::Sum(pHistData->GetNH(), nEdges));
	float*pCumSum= DsMathLibrary::CumSum(pN_H, nEdges);
	delete []pN_H;
	bool*pCumSumWithPercent = DsMathLibrary::CheckLessThan(pCumSum, nEdges, NoiseThreshold); 
	delete []pCumSum;

	float nn_H = DsMathLibrary::Sum(pCumSumWithPercent, nEdges);
	delete []pCumSumWithPercent;
	float I_L_0 = 0.0f;
	if (nn_H >= 0 && nn_H <= nEdges)
	{
		I_L_0 = pHistData->GetEdges()[(int)nn_H-1]; //-1 because Matlab use 1 base index and c++ use zero base index
	}
	return I_L_0;
}
template<>
bool DsMemoryImage<DsDWORD>::CombineSENCImages(DsBaseMemoryImage * pByteImage ,DsBaseMemoryImage * pFloatImage ,DsPalette*  pGrayPalette,DsPalette*  pStrainPalette, enDisplayMode DisplayMode)
{
	if (!pByteImage || !pFloatImage || !pGrayPalette || !pStrainPalette )
	{
		DSERROR(_CLASS_FUNCTION_NAME_,GetObjectName(),(ERROR_GLOBAL_USER_BAD_ELEMENT_VALUE_PTR),P3,false);
		return false;
	}
	if(!pByteImage->GetImageSize()	|| !pFloatImage->GetImageSize()	|| (pFloatImage->GetBitsPerPixel()!=32))
	{
		DSERROR(_CLASS_FUNCTION_NAME_,GetObjectName(),(ERROR_DS_MEMORY_IMAGE_SIZE_ERROR),P3,false);
		return false;
	}
	int ByteImageHeight = pByteImage->GetHeight();
	int FloatImageHeight = pFloatImage->GetHeight();
	int ByteImageWidth = pByteImage->GetWidth();
	int FloatImageWidth = pFloatImage->GetWidth();
	DsBaseMemoryImage*pTempByteImage  = pByteImage;
	DsBaseMemoryImage*pTempFloatImage = pFloatImage;
	bool bDeleteTempImages = false;
	int noiseColor = DisplayMode == enDisplayMode::WHITE_DISPLAY_MODE ? 255 : 0;
	if(ByteImageHeight != FloatImageHeight || ByteImageWidth!=FloatImageWidth)
	{
		bDeleteTempImages = true;
		ByteImageWidth  = max(ByteImageWidth,FloatImageWidth);
		ByteImageHeight = max(ByteImageHeight,FloatImageHeight);
		pTempByteImage = pByteImage->GetImageWithBigSize(ByteImageWidth,ByteImageHeight);
		pTempFloatImage = pFloatImage->GetImageWithBigSize(ByteImageWidth,ByteImageHeight);
	}
	int ImageSize = ByteImageHeight*ByteImageWidth;
	AllocateBuffer(ByteImageWidth,ByteImageHeight,32);
	float* pTempStrainBuffer=(float*)pTempFloatImage->GetBuffer();
	if (pByteImage->GetBitsPerPixel()==8)
	{
		DsBYTE*  pTempGridBuffer=(DsBYTE*)pTempByteImage->GetBuffer();
		DsBYTE*  pTempBuffer=(DsBYTE*)m_pData;
		DsColour*pSTrainColor=NULL;
		DsColour*pGreyColor=NULL;
		for (int Count=0;Count<ImageSize;Count++,pTempGridBuffer++,pTempStrainBuffer++)
		{
			pSTrainColor=pStrainPalette->GetPixelValue(*pTempStrainBuffer);
			pGreyColor=pGrayPalette->GetPixelValue((float)(*pTempGridBuffer*255));
			if (*pTempGridBuffer == 0 || FLOAT_EQ(*pTempStrainBuffer, UNDEFINED_VALUE))
			{
				*pTempBuffer=(DsBYTE)noiseColor;
				pTempBuffer++;
				*pTempBuffer=(DsBYTE)noiseColor;
				pTempBuffer++;
				*pTempBuffer=(DsBYTE)noiseColor;
				pTempBuffer++;
				*pTempBuffer=0;
				pTempBuffer++;
				continue;
			}
			
			*pTempBuffer=CalculateCombinedColorValueForSENC(pSTrainColor->Set.b,pGreyColor->Set.b, DisplayMode);//(pSTrainColor->Set.b * pGreyColor->Set.b)/255;
			pTempBuffer++;
			*pTempBuffer=CalculateCombinedColorValueForSENC(pSTrainColor->Set.g,pGreyColor->Set.g, DisplayMode);//(pSTrainColor->Set.g * pGreyColor->Set.g)/255;
			pTempBuffer++;
			*pTempBuffer=CalculateCombinedColorValueForSENC(pSTrainColor->Set.r,pGreyColor->Set.r, DisplayMode);//(pSTrainColor->Set.r * pGreyColor->Set.r)/255;
			pTempBuffer++;
			*pTempBuffer=0;
			pTempBuffer++;
		}
	}
	else
	{
		float*  pTempGridBuffer=(float*)pTempByteImage->GetBuffer();
		DsBYTE*  pTempBuffer=(DsBYTE*)m_pData;
		DsColour*pSTrainColor=NULL;
		DsColour*pGreyColor=NULL;
		for (int Count=0;Count<ImageSize;Count++,pTempGridBuffer++,pTempStrainBuffer++)
		{
			pSTrainColor=pStrainPalette->GetPixelValue(*pTempStrainBuffer);
			pGreyColor=pGrayPalette->GetPixelValue(*pTempGridBuffer*255);
			if (*pTempGridBuffer == 0 || FLOAT_EQ(*pTempStrainBuffer, UNDEFINED_VALUE))
			{
				*pTempBuffer=(DsBYTE)noiseColor;
				pTempBuffer++;
				*pTempBuffer=(DsBYTE)noiseColor;
				pTempBuffer++;
				*pTempBuffer=(DsBYTE)noiseColor;
				pTempBuffer++;
				*pTempBuffer=0;
				pTempBuffer++;
				continue;
			}
			*pTempBuffer=CalculateCombinedColorValueForSENC(pSTrainColor->Set.b,pGreyColor->Set.b, DisplayMode);
			pTempBuffer++;
			*pTempBuffer=CalculateCombinedColorValueForSENC(pSTrainColor->Set.g,pGreyColor->Set.g, DisplayMode);
			pTempBuffer++;
			*pTempBuffer=CalculateCombinedColorValueForSENC(pSTrainColor->Set.r,pGreyColor->Set.r, DisplayMode);
			pTempBuffer++;
			*pTempBuffer=0;
			pTempBuffer++;
		}
	}

	if (bDeleteTempImages)
	{
		delete pTempFloatImage;
		delete pTempByteImage;
	}
	
	return true;
}
